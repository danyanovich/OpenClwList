// localStorage-based task storage — replaces SQLite tasks table

export type TaskStatus = 'planned' | 'in_progress' | 'waiting_approval' | 'review' | 'done'

export type TaskItem = {
  id: string
  title: string
  description?: string
  status: TaskStatus
  sourceRunId?: string
  sessionKey?: string
  autoGenerated: boolean
  createdAt: number
  updatedAt: number
  tags?: string[]
  topic?: string
}

const TASKS_KEY = 'openclaw_tasks'

function read(): TaskItem[] {
  try {
    if (typeof window === 'undefined') return []
    const raw = localStorage.getItem(TASKS_KEY)
    if (!raw) return []
    return JSON.parse(raw) as TaskItem[]
  } catch {
    return []
  }
}

function write(tasks: TaskItem[]): void {
  try {
    localStorage.setItem(TASKS_KEY, JSON.stringify(tasks))
  } catch {
    // quota exceeded or SSR — ignore
  }
}

export function loadTasks(): TaskItem[] {
  return read()
}

export function createTask(fields: Omit<TaskItem, 'id' | 'createdAt' | 'updatedAt'>): TaskItem {
  const tasks = read()
  const task: TaskItem = {
    ...fields,
    id: `task-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    createdAt: Date.now(),
    updatedAt: Date.now(),
  }
  write([...tasks, task])
  return task
}

export function updateTask(id: string, fields: Partial<TaskItem>): TaskItem | null {
  const tasks = read()
  const idx = tasks.findIndex((t) => t.id === id)
  if (idx === -1) return null
  const updated = { ...tasks[idx]!, ...fields, id, updatedAt: Date.now() }
  const next = [...tasks]
  next[idx] = updated
  write(next)
  return updated
}

export function deleteTask(id: string): boolean {
  const tasks = read()
  const filtered = tasks.filter((t) => t.id !== id)
  if (filtered.length === tasks.length) return false
  write(filtered)
  return true
}

export function getTask(id: string): TaskItem | null {
  return read().find((t) => t.id === id) ?? null
}

// Auto-upsert task from a run (called when gateway emits a run with user prompt)
export function upsertAutoTaskForRun(params: {
  runId: string
  sessionKey?: string
  title: string
  description?: string
}): { created: boolean; updated: boolean; taskId: string } {
  const tasks = read()
  const existing = tasks.find((t) => t.sourceRunId === params.runId)
  if (existing) {
    const changed = params.title && existing.title !== params.title
    if (changed) {
      updateTask(existing.id, { title: params.title, description: params.description })
      return { created: false, updated: true, taskId: existing.id }
    }
    return { created: false, updated: false, taskId: existing.id }
  }
  const task = createTask({
    title: params.title || 'Untitled run',
    description: params.description,
    status: 'in_progress',
    sourceRunId: params.runId,
    sessionKey: params.sessionKey,
    autoGenerated: true,
  })
  return { created: true, updated: false, taskId: task.id }
}

// Update task status when a run finishes
export function updateAutoTaskStatusByRun(
  runId: string,
  runState: 'running' | 'final' | 'error' | 'aborted',
): void {
  const tasks = read()
  const task = tasks.find((t) => t.sourceRunId === runId && t.autoGenerated)
  if (!task) return
  if (runState === 'final') updateTask(task.id, { status: 'review' })
  else if (runState === 'error' || runState === 'aborted') updateTask(task.id, { status: 'planned' })
}
